# ansible_env_ready.yml
---
- name: Setup Base System and Dependencies (Multi-OS)
  hosts: localhost
  gather_facts: yes
  become: yes

  vars:
    # 공통 변수
    sqlite_download_url: "https://raw.githubusercontent.com/negun2/soldesk/main/files/sqlite-snapshot-202505171106.tar.gz"
    sqlite_downloaded_filename: "sqlite-snapshot-202505171106.tar.gz"
    sqlite_download_dest_dir: "/tmp/sqlite_downloaded"
    sqlite_install_prefix: "/usr/local"

    # OS별 변수 파일 다운로드 URL 및 경로
    os_vars_base_url: "https://raw.githubusercontent.com/negun2/soldesk/refs/heads/main/vars"
    downloaded_vars_dir: "{{ ansible_user_dir | default('/home/vagrant') }}/downloaded_vars"

  tasks:
    - name: Create directory for downloaded OS vars files
      file:
        path: "{{ downloaded_vars_dir }}"
        state: directory
        mode: '0755'

    - name: Download OS-specific var files from GitHub
      get_url:
        url: "{{ os_vars_base_url }}/{{ item }}"
        dest: "{{ downloaded_vars_dir }}/{{ item }}"
        mode: '0644'
      loop:
        - "RedHat.yml"
        - "Debian.yml"
        # 추가적인 OS별 _django.yml 파일 등을 사용한다면 여기에 추가
      ignore_errors: yes # 특정 파일이 없을 경우 대비


    # --- 변수 로드 방식을 slurp + set_fact으로 변경 ---
    - name: Read RedHat vars file content
      slurp:
        src: "{{ downloaded_vars_dir }}/RedHat.yml"
      register: redhat_vars_file_b64
      when: ansible_os_family == "RedHat"
      ignore_errors: yes # 파일이 없을 경우 대비

    - name: Set facts from RedHat vars file
      set_fact:
        # b64decode로 디코딩 후 from_yaml로 파싱
        # update_vars를 사용하여 기존 변수와 병합 (또는 os_vars 와 같이 새로운 변수로 그룹화)
        # 여기서는 직접 변수 공간에 등록
        "{{ item.key }}": "{{ item.value }}"
      loop: "{{ (redhat_vars_file_b64.content | b64decode | from_yaml) | dict2items }}"
      when: ansible_os_family == "RedHat" and redhat_vars_file_b64.content is defined
      no_log: true # 변수 내용이 로그에 많이 남지 않도록

    - name: Read Debian vars file content
      slurp:
        src: "{{ downloaded_vars_dir }}/Debian.yml"
      register: debian_vars_file_b64
      when: ansible_os_family == "Debian"
      ignore_errors: yes

    - name: Debug debian_vars_file_b64 content before set_facts
      debug:
        var: debian_vars_file_b64 # slurp 결과를 직접 확인
      when: ansible_os_family == "Debian"

    - name: Set facts from Debian vars file
      set_fact:
        "{{ item.key }}": "{{ item.value }}"
      loop: "{{ (debian_vars_file_b64.content | b64decode | from_yaml | default({})) | dict2items }}"
      when: ansible_os_family == "Debian" and debian_vars_file_b64.content is defined and debian_vars_file_b64.content != ""
      no_log: true

    # --- RedHat 계열 패키지 설치 전에도 디버깅 추가 (유사하게) ---
    - name: Debug redhat_vars_file_b64 content before set_facts
      debug:
        var: redhat_vars_file_b64
      when: ansible_os_family == "RedHat"

    - name: Set facts from RedHat vars file
      set_fact:
        "{{ item.key }}": "{{ item.value }}"
      no_log: true # <--- 주석 처리 또는 삭제
      loop: "{{ (redhat_vars_file_b64.content | b64decode | from_yaml | default({})) | dict2items }}"
      when: ansible_os_family == "RedHat" and redhat_vars_file_b64.content is defined and redhat_vars_file_b64.content != ""

    # --- RedHat 계열 패키지 설치 ---
    - name: Install base packages (RedHat family)
      yum:
        name:
          - epel-release
          - python3
          - python3-pip
          - gcc
          - "{{ python_dev_package_name }}"
          - "{{ apache_package_name }}"
          - "{{ apache_dev_package_name }}"
          - "{{ mod_wsgi_package_name_system }}" # 시스템 Apache용 mod_wsgi
          - "{{ python_virtualenv_package_name }}"
          - wget
          - "{{ readline_dev_package_name }}"
          - "{{ zlib_dev_package_name }}"
          - "{{ libffi_dev_package_name }}"
          - "{{ libssl_dev_package_name }}"
          - "{{ policycoreutils_package_name }}"
        state: present
      when: ansible_os_family == "RedHat"

    # --- 패키지 설치 태스크 바로 전에 로드된 변수 값 확인 ---
    - name: Debug effective package vars (Debian)
      debug:
        msg:
          - "python_dev_package_name: {{ python_dev_package_name | default('NOT SET') }}"
          - "apache_package_name: {{ apache_package_name | default('NOT SET') }}"
          - "{{ apache_dev_package_name | default('NOT SET') }}"
          - "{{ mod_wsgi_package_name_system | default('NOT SET') }}"
          - "{{ python_virtualenv_package_name | default('NOT SET') }}"
          - wget
          - "{{ readline_dev_package_name | default('NOT SET') }}"
          - "{{ zlib_dev_package_name | default('NOT SET') }}"
          - "{{ libffi_dev_package_name | default('NOT SET') }}"
          - "{{ libssl_dev_package_name | default('NOT SET') }}"
          - "{{ apparmor-utils_package_name | default('NOT SET') }}"
      when: ansible_os_family == "Debian"

    # --- Debian 계열 패키지 설치 ---
    - name: Install base packages (Debian family)
      apt:
        name:
          - python3
          - python3-pip
          - gcc
          - "{{ python_dev_package_name }}"
          - "{{ apache_package_name }}"
          - "{{ apache_dev_package_name }}"
          - "{{ mod_wsgi_package_name_system }}" # 시스템 Apache용 mod_wsgi
          - "{{ python_virtualenv_package_name }}"
          - wget
          - "{{ readline_dev_package_name }}"
          - "{{ zlib_dev_package_name }}"
          - "{{ libffi_dev_package_name }}"
          - "{{ libssl_dev_package_name }}"
          - "{{ apparmor_utils_package_name }}"

        state: present
        update_cache: yes
      when: ansible_os_family == "Debian"

    - name: Install 'Development Tools' group (RedHat family only)
      yum:
        name: "@Development Tools"
        state: present
      when: ansible_os_family == "RedHat"

    - name: Install 'build-essential' (Debian family for development tools)
      apt:
        name: build-essential
        state: present
      when: ansible_os_family == "Debian"

    - name: Create download and extraction directory for SQLite
      file:
        path: "{{ sqlite_download_dest_dir }}"
        state: directory
        mode: '0755'

    - name: Download SQLite source from GitHub
      get_url:
        url: "{{ sqlite_download_url }}"
        dest: "{{ sqlite_download_dest_dir }}/{{ sqlite_downloaded_filename }}"
        mode: '0644'
      register: sqlite_download_status
      until: sqlite_download_status is succeeded
      retries: 3
      delay: 5

    - name: Unarchive SQLite source
      unarchive:
        src: "{{ sqlite_download_dest_dir }}/{{ sqlite_downloaded_filename }}"
        dest: "{{ sqlite_download_dest_dir }}"
        remote_src: yes
      register: sqlite_unarchive_result

    - name: Configure SQLite
      command: "./configure --prefix={{ sqlite_install_prefix }} --enable-shared --enable-fts5"
      args:
        chdir: "{{ sqlite_unarchive_result.dest }}/{{ sqlite_downloaded_filename | basename | regex_replace('.tar.gz$', '') }}"
      changed_when: false

    - name: Compile SQLite
      command: "make -j{{ ansible_processor_vcpus | default(1) }}"
      args:
        chdir: "{{ sqlite_unarchive_result.dest }}/{{ sqlite_downloaded_filename | basename | regex_replace('.tar.gz$', '') }}"
      changed_when: false

    - name: Install SQLite
      command: "make install"
      args:
        chdir: "{{ sqlite_unarchive_result.dest }}/{{ sqlite_downloaded_filename | basename | regex_replace('.tar.gz$', '') }}"

    - name: Configure dynamic linker run-time bindings for SQLite
      copy:
        content: "{{ sqlite_install_prefix }}/lib"
        dest: /etc/ld.so.conf.d/sqlite3-custom.conf
        mode: '0644'
      notify: Run ldconfig

    - name: Clean up SQLite download and extraction directory
      file:
        path: "{{ sqlite_download_dest_dir }}"
        state: absent

  handlers:
    - name: Run ldconfig
      command: ldconfig

# --- 두 번째 플레이: Setup Django Web Environment (Multi-OS) ---
- name: Setup Django Web Environment (Multi-OS)
  hosts: localhost
  become: yes
  gather_facts: yes

  vars:
    # 공통 변수 (target_user_home, project_root_dir 등)
    target_user_home: "/var/www" # 또는 /srv 등 웹 콘텐츠 표준 경로
    target_user: "www-data"      # 프로젝트 파일 소유자를 www-data로 (또는 다른 웹 전용 사용자)
    project_root_dir: "{{ target_user_home }}/{{ django_project_name | default('onpremweb_app') }}" # 예: /var/www/onpremweb_app
    venv_dir: "{{ project_root_dir }}/venv"
    django_project_name: "onpremweb" # 로그 파일명, Apache 설정 파일명 등에 사용
    django_project_config_name: "onprem_project_config" # Django 프로젝트 내부 설정 디렉토리
    django_version: "3.2.25"


    # GitHub에서 가져오는 파일들 URL
    os_vars_base_url: "https://raw.githubusercontent.com/negun2/soldesk/main/vars"
    apache_conf_template_download_url: "https://raw.githubusercontent.com/negun2/soldesk/main/templates/django_onpremweb.conf.j2"
    apache_conf_template_downloaded_filename: "django_onpremweb.conf.j2"

    # 임시 다운로드 경로 (첫 번째 플레이와 동일한 경로 사용 가능, 또는 고유 경로)
    downloaded_vars_dir: "{{ ansible_user_dir | default('/home/vagrant') }}/downloaded_vars" # 첫 번째 플레이와 동일하게 사용
    vm_templates_dir: "{{ (ansible_user_dir | default('/home/vagrant')) }}/templates_downloadeds" # 또는 /tmp/templates_downloaded

    # Apache 관련 변수 (OS별 vars 파일에서 덮어쓰여짐)
    apache_user: "www-data" # Ubuntu 기본값, RedHat.yml에서 "apache"로 덮어쓰여짐
    apache_group: "www-data" # Ubuntu 기본값, RedHat.yml에서 "apache"로 덮어쓰여짐
    apache_conf_dir: ""
    apache_sites_enabled_dir: ""
    apache_service_name: ""
    mod_wsgi_load_file_content_django: ""
    apache_log_dir: "" # OS별 vars 파일에서 정의 (예: /var/log/apache2 또는 /var/log/httpd)
    server_name_ip: "{{ ansible_default_ipv4.address if ansible_default_ipv4.address is defined else '127.0.0.1' }}"
    apache_wsgi_daemon_name: "onpremweb_daemon"

  tasks:

    - name: Include OS-specific variables for Django
      include_vars:
        file: "{{ downloaded_vars_dir }}/{{ ansible_os_family }}.yml"
      ignore_errors: yes

    - name: Ensure project parent directory exists and has correct permissions
      file:
        path: "{{ target_user_home }}" # 예: /var/www
        state: directory
        owner: root # 또는 적절한 관리자
        group: root # 또는 적절한 그룹
        mode: '0755' # 다른 사용자가 접근 가능하도록

    - name: Ensure project directory exists with correct owner/group
      file:
        path: "{{ project_root_dir }}" # 예: /var/www/onpremweb_app
        state: directory
        owner: "{{ target_user }}" # www-data
        group: "{{ target_user }}" # www-data
        mode: '0755'

    - name: Create Python virtual environment
      command: "python3 -m venv {{ venv_dir }}"
      args:
        creates: "{{ venv_dir }}/bin/activate"
      become: yes # root로 실행 후,
      become_user: "{{ target_user }}" # www-data 사용자로 venv 생성

    - name: Install wheel in virtual environment before mod_wsgi
      pip:
        name: wheel
        virtualenv: "{{ venv_dir }}"
        virtualenv_python: python3
      become_user: "{{ target_user }}" # 가상환경 작업은 해당 사용자 권한으로

    - name: Install Django and mod_wsgi in virtual environment
      pip:
        name:
          - "django=={{ django_version }}"
          - mod_wsgi # 가상환경에 mod_wsgi 설치 (Apache가 이 환경을 사용)
        virtualenv: "{{ venv_dir }}"
        virtualenv_python: python3
      become_user: "{{ target_user }}"

    - name: Ensure mod_wsgi module is loaded in Apache (RedHat family)
      copy: # RedHat에서는 mod_wsgi 로드 파일을 직접 관리할 수 있음
        content: "{{ mod_wsgi_load_file_content_django | default('LoadModule wsgi_module modules/mod_wsgi_python3.so') }}"
        dest: "/etc/httpd/conf.modules.d/10-wsgi-custom.conf" # 시스템 패키지와 다른 이름 사용
        owner: root
        group: root
        mode: '0644'
      when: ansible_os_family == "RedHat"
      notify: Restart Apache

    - name: Check for wsgi_py3 module availability (Debian family)
      stat:
        path: "/etc/apache2/mods-available/wsgi_py3.load" # 일반적인 파일명
      register: wsgi_py3_load_file_stat
      when: ansible_os_family == "Debian"

    - name: Check for wsgi (generic) module availability (Debian family) - fallback
      stat:
        path: "/etc/apache2/mods-available/wsgi.load" # 다른 가능한 파일명
      register: wsgi_load_file_stat
      when: ansible_os_family == "Debian" and not wsgi_py3_load_file_stat.stat.exists

    - name: Determine correct wsgi module name for a2enmod (Debian family)
      set_fact:
        apache_wsgi_module_name_debian: "{{ 'wsgi_py3' if wsgi_py3_load_file_stat.stat.exists else ('wsgi' if wsgi_load_file_stat.stat.exists else '') }}"
      when: ansible_os_family == "Debian"

    - name: Enable wsgi module on Debian family
      command: "a2enmod {{ apache_wsgi_module_name_debian }}"
      args:
        creates: "/etc/apache2/mods-enabled/{{ apache_wsgi_module_name_debian }}.load"
      when: ansible_os_family == "Debian" and apache_wsgi_module_name_debian # 모듈 이름이 결정되었을 때만 실행
      notify: Restart Apache
      changed_when: true # a2enmod는 성공 시 항상 changed 상태를 반환하도록 가정 (또는 register + changed_when 사용)

    - name: Create Django project
      command: "{{ venv_dir }}/bin/django-admin startproject {{ django_project_config_name }} ." # 현재 디렉토리에 프로젝트 파일 생성
      args:
        chdir: "{{ project_root_dir }}" # 프로젝트 루트 디렉토리에서 실행
        creates: "{{ project_root_dir }}/manage.py"
      become: yes
      become_user: "{{ target_user }}"

    - name: Configure Django settings
      lineinfile:
        path: "{{ project_root_dir }}/{{ django_project_config_name }}/settings.py"
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        insertafter: "{{ item.insertafter | default('^# Application definition') }}"
        create: yes
      loop:
        - { regexp: "^STATIC_URL = .*", line: "STATIC_URL = '/static/'", insertafter: "^BASE_DIR = .*" }
        - { regexp: "^STATIC_ROOT = .*", line: "STATIC_ROOT = BASE_DIR / 'staticfiles'", insertafter: "^BASE_DIR = .*" }
        - { regexp: "^MEDIA_URL = .*", line: "MEDIA_URL = '/media/'", insertafter: "^BASE_DIR = .*" }
        - { regexp: "^MEDIA_ROOT = .*", line: "MEDIA_ROOT = BASE_DIR / 'mediafiles'", insertafter: "^BASE_DIR = .*" }
        - { regexp: "^ALLOWED_HOSTS = .*", line: "ALLOWED_HOSTS = ['*']" }
        - { regexp: "^# import os", line: "import os", insertbefore: "^BASE_DIR = .*" }

    - name: Create staticfiles and mediafiles directories
      file:
        path: "{{ project_root_dir }}/{{ staticfiles }}"
        state: directory
        owner: "{{ target_user }}"
        group: "{{ target_user }}"
        mode: '0755'
      loop:
        - staticfiles
        - mediafiles
      become_user: "{{ target_user }}"

    - name: Collect static files
      command: "{{ venv_dir }}/bin/python {{ project_root_dir }}/manage.py collectstatic --noinput"
      become_user: "{{ target_user }}"
      args:
        chdir: "{{ project_root_dir }}"


    - name: Set permissions for project directory for Apache
      file:
        path: "{{ item }}"
        owner: "{{ target_user }}"
        group: "{{ apache_group }}" # OS별 Apache 그룹
        mode: "{{ 'g+rX' if item == project_root_dir else '0775' }}"
        recurse: "{{ 'yes' if item != project_root_dir else 'no' }}"
      loop:
        - "{{ project_root_dir }}"
        - "{{ project_root_dir }}/staticfiles"
        - "{{ project_root_dir }}/mediafiles"
        - "{{ venv_dir }}"

    - name: Allow Apache to search user's home directory
      file:
        path: "{{ target_user_home }}"
        mode: '0755' # 좀 더 명확한 권한 (소유자rwx, 그룹rx, otherrx)

    #- name: Create directory for downloaded Apache template on VM
    #  file:
    #    path: "{{ vm_templates_dir }}"
    #    state: directory
    #    mode: '0755'

    #- name: Download Apache config template from GitHub
    #  get_url:
    #    url: "{{ apache_conf_template_download_url }}"
    #    dest: "{{ vm_templates_dir }}/{{ apache_conf_template_downloaded_filename }}"
    #    mode: '0644'

    - name: Download Apache config template to /tmp on VM
      get_url:
        url: "{{ apache_conf_template_download_url }}"
        dest: "/tmp/{{ apache_conf_template_downloaded_filename }}" # /tmp 아래로 직접 다운로드
        mode: '0644'
      # register, until 등은 유지 가능

    - name: Debug key variables before Apache conf deployment
      debug:
        msg:
          - "apache_wsgi_daemon_name: {{ apache_wsgi_daemon_name | default('NOT DEFINED') }}"
          - "OS Family: {{ ansible_os_family }}"
          - "Decoded Template Preview: {{ (apache_template_content_b64.content | b64decode)[:300] if apache_template_content_b64.content is defined else 'TEMPLATE CONTENT NOT SLURPED' }}"
          - "apache_wsgi_daemon_name: {{ apache_wsgi_daemon_name | default('NOT DEFINED') }}"
          - "apache_user: {{ apache_user | default('NOT DEFINED') }}"
          - "apache_group: {{ apache_group | default('NOT DEFINED') }}"
          - "venv_dir: {{ venv_dir | default('NOT DEFINED') }}"
          - "project_root_dir: {{ project_root_dir | default('NOT DEFINED') }}"
          - "server_name_ip: {{ server_name_ip | default('NOT DEFINED') }}" # 이 변수도 vars에 정의 필요
          - "django_project_name: {{ django_project_name | default('NOT DEFINED') }}"
          - "django_project_config_name: {{ django_project_config_name | default('NOT DEFINED') }}"
          - "apache_conf_dir: {{ apache_conf_dir | default('NOT DEFINED FROM VARS') }}"
          - "Template source path for template module: /tmp/{{ apache_conf_template_downloaded_filename }}"

    - name: Deploy Apache virtual host configuration for Django (using template module)
      template:
        src: "/tmp/{{ apache_conf_template_downloaded_filename }}" # /tmp 아래의 파일 직접 지정
        remote_src: yes  # VM 내의 파일을 소스로 사용함을 명시
        dest: "{{ apache_conf_dir }}/{{ django_project_name }}.conf"
        owner: root
        group: root
        mode: '0644'
      notify: Restart Apache

    - name: Clean up downloaded Apache template file from /tmp
      file:
        path: "/tmp/{{ apache_conf_template_downloaded_filename }}"
        state: absent

    - name: Enable Apache site (Debian family only)
      command: "a2ensite {{ django_project_name }}"
      args:
        creates: "{{ apache_sites_enabled_dir }}/{{ django_project_name }}.conf" # OS별 활성화된 사이트 경로
      when: ansible_os_family == "Debian"
      notify: Restart Apache

    - name: Ensure Apache service is enabled and running
      service:
        name: "{{ apache_service_name }}" # OS별 서비스 이름 사용
        state: started
        enabled: yes

    - name: Configure SELinux for Apache (RedHat family only)
      block:
        - name: Allow httpd to access project files (SELinux)
          sefcontext:
            target: "{{ project_root_dir }}(/.*)?"
            setype: httpd_sys_content_t
            state: present
          notify: Restore SELinux context

        - name: Allow httpd to access user home directories (SELinux boolean)
          seboolean:
            name: httpd_enable_homedirs
            state: yes
            persistent: yes
      when: ansible_os_family == "RedHat"
      ignore_errors: yes # policycoreutils-python 없을 경우 대비

    - name: Ensure firewall is configured for http
      block:
        - name: Allow http on firewalld (RedHat family)
          firewalld:
            service: http
            permanent: yes
            state: enabled
          notify: Reload firewalld
          when: ansible_os_family == "RedHat"

        - name: Allow http on ufw (Debian family)
          ufw:
            rule: allow
            port: '80'
            proto: tcp
          notify: Reload ufw
          when: ansible_os_family == "Debian"
      ignore_errors: yes

  handlers:
    - name: Restart Apache
      service:
        name: "{{ apache_service_name }}"
        state: restarted

    - name: Restore SELinux context
      command: "restorecon -Rv {{ project_root_dir }}"
      when: ansible_os_family == "RedHat"

    - name: Reload firewalld
      service:
        name: firewalld
        state: reloaded
      when: ansible_os_family == "RedHat"

    - name: Reload ufw
      command: ufw reload # 또는 service 모듈 사용 (ufw 서비스가 systemd로 관리된다면)
      when: ansible_os_family == "Debian"
