# ansible_env_ready.yml
---
- name: Setup Base System and Dependencies (Multi-OS)
  hosts: localhost
  gather_facts: yes
  become: yes

  vars:
    # 공통 변수
    sqlite_download_url: "https://raw.githubusercontent.com/negun2/soldesk/main/files/sqlite-snapshot-202505171106.tar.gz"
    sqlite_downloaded_filename: "sqlite-snapshot-202505171106.tar.gz"
    sqlite_download_dest_dir: "/tmp/sqlite_downloaded" # 임시 사용 후 삭제되므로 /tmp 사용 무방
    sqlite_install_prefix: "/usr/local"

    # OS별 변수 파일 다운로드 URL 및 경로
    os_vars_base_url: "https://raw.githubusercontent.com/negun2/soldesk/refs/heads/main/vars"
    # ansible_user_dir은 gather_facts:yes 일 때 보통 ansible_facts.user_dir 로 접근 가능
    # 또는 ansible_env.HOME 사용 가능. 여기서는 명시적으로 lookup 사용.
    current_vars_download_user_home: "{{ lookup('env', 'HOME') }}" # 플레이북 실행 환경의 HOME
    downloaded_vars_dir: "{{ current_vars_download_user_home }}/downloaded_vars_play1" # 첫 번째 플레이에서만 사용하고 정리될 수 있도록

    ius_release_rpm_url: "https://repo.ius.io/ius-release-el7.rpm"
    python_target_version_short: "3.9"
        # IUS 패키지명 규칙은 보통 python<버전숫자><u 또는 다른 접미사>
    # 예: python39, python310u
    # 정확한 패키지명은 `yum search python3 | grep ius` 등으로 확인 필요
    python_target_package_name_rh: "python{{ python_target_version_short | replace('3.9', 'python39') }}" # 예: python39
    pip_target_package_name_rh: "python{{ python_target_version_short | replace('3.9', 'python39') }}-pip"
    devel_target_package_name_rh: "python{{ python_target_version_short | replace('3.9', 'python39') }}-devel"
    venv_target_package_name_rh: "python{{ python_target_version_short | replace('3.9', 'python39') }}-virtualenv" # 또는 새 python의 내장 venv 사용

  tasks:
    - name: Create directory for downloaded OS vars files
      file:
        path: "{{ downloaded_vars_dir }}"
        state: directory
        mode: '0755'
      # become: no # 현재 사용자 권한으로 생성 (만약 become: yes 상태라면 root로 생성됨)
      # delegate_to: localhost # 명시적으로 로컬에서 실행

    - name: Download OS-specific var files from GitHub
      get_url:
        url: "{{ os_vars_base_url }}/{{ item }}"
        dest: "{{ downloaded_vars_dir }}/{{ item }}"
        mode: '0644'
      loop:
        - "RedHat.yml"
        - "Debian.yml"
      ignore_errors: yes
      # delegate_to: localhost

    # --- 변수 로드 방식 (기존 slurp + set_fact 유지) ---
    - name: Read RedHat vars file content
      slurp:
        src: "{{ downloaded_vars_dir }}/RedHat.yml"
      register: redhat_vars_file_b64
      when: ansible_os_family == "RedHat"
      ignore_errors: yes
      # delegate_to: localhost

    - name: Set facts from RedHat vars file
      set_fact:
        "{{ item.key }}": "{{ item.value }}"
      loop: "{{ (redhat_vars_file_b64.content | b64decode | from_yaml | default({})) | dict2items }}"
      when: ansible_os_family == "RedHat" and redhat_vars_file_b64.content is defined and redhat_vars_file_b64.content != ""
      no_log: true
      # delegate_to: localhost

    - name: Read Debian vars file content
      slurp:
        src: "{{ downloaded_vars_dir }}/Debian.yml"
      register: debian_vars_file_b64
      when: ansible_os_family == "Debian"
      ignore_errors: yes
      # delegate_to: localhost

    - name: Set facts from Debian vars file
      set_fact:
        "{{ item.key }}": "{{ item.value }}"
      loop: "{{ (debian_vars_file_b64.content | b64decode | from_yaml | default({})) | dict2items }}"
      when: ansible_os_family == "Debian" and debian_vars_file_b64.content is defined and debian_vars_file_b64.content != ""
      no_log: true
      # delegate_to: localhost

# --- Python 버전 업그레이드 (RedHat family, IUS) ---
    - name: Install IUS Community repository (RedHat family only, if not already done)
      yum:
        name: "{{ ius_release_rpm_url }}"
        state: present
        disable_gpg_check: yes
      when: ansible_os_family == "RedHat"

    - name: Install target Python version and related tools (RedHat family, IUS)
      yum:
        name:
          - "{{ python_target_package_name_rh }}"
          - "{{ pip_target_package_name_rh }}"
          - "{{ devel_target_package_name_rh }}"
          # - "{{ venv_target_package_name_rh }}" # 새 Python에 내장된 venv를 사용할 것이므로 필수는 아닐 수 있음
        state: present
      when: ansible_os_family == "RedHat"
      notify: Update alternatives for python3 # 핸들러 추가

    # 기존 시스템 python3 패키지들을 새 버전으로 대체하거나 공존시킴 (alternatives 사용)
    # 또는, 이후 작업에서 python3 대신 python3.9 (또는 python{{ python_target_version_short }})를 명시적으로 사용

    # ... (기존 RedHat/Debian 패키지 설치 - 여기서는 시스템 기본 python3 관련 패키지는 제외하거나 조정 필요) ...
    # 예를 들어, python_dev_package_name 등을 위에서 설치한 devel_target_package_name_rh 로 대체

    # RedHat 계열 패키지 설치 (기존 python3 대신 새 버전 사용하도록 일부 수정)
    - name: Install base packages (RedHat family) - Adjusted for new Python
      yum:
        name:
          - epel-release
          # - python3 # <--- 위에서 특정 버전(예: python39)을 설치했으므로, 시스템 기본 python3는 건너뛰거나,
          #             # alternatives로 새 버전을 기본 python3로 설정했다면 유지 가능.
          # - python3-pip # <--- 위에서 특정 버전 pip 설치
          - gcc
          # - "{{ python_dev_package_name | default(omit) }}" # <--- devel_target_package_name_rh 로 대체됨
          - "{{ apache_package_name | default(omit) }}"
          - "{{ apache_dev_package_name | default(omit) }}"
          # - "{{ mod_wsgi_package_name_system | default(omit) }}" # <--- 새 Python용 mod_wsgi 필요할 수 있음 (pip으로 설치 권장)
          # - "{{ python_virtualenv_package_name | default(omit) }}" # <--- venv_target_package_name_rh 또는 내장 venv 사용
          - wget
          - "{{ readline_dev_package_name | default(omit) }}"
          - "{{ zlib_dev_package_name | default(omit) }}"
          - "{{ libffi_dev_package_name | default(omit) }}"
          - "{{ libssl_dev_package_name | default(omit) }}"
          - "{{ policycoreutils_package_name | default(omit) }}"
        state: present
      when: ansible_os_family == "RedHat"

    # Debian 계열 패키지 설치 (python3, python3-pip 등)
    - name: Install base packages (Debian family)
      apt:
        name:
          - python3
          - python3-pip
          - gcc
          - "{{ python_dev_package_name | default(omit) }}" # OS별 변수
          - "{{ apache_package_name | default(omit) }}"
          - "{{ apache_dev_package_name | default(omit) }}"
          - "{{ mod_wsgi_package_name_system | default(omit) }}"
          - "{{ python_virtualenv_package_name | default(omit) }}"
          - wget
          - "{{ readline_dev_package_name | default(omit) }}"
          - "{{ zlib_dev_package_name | default(omit) }}"
          - "{{ libffi_dev_package_name | default(omit) }}"
          - "{{ libssl_dev_package_name | default(omit) }}"
          - "{{ apparmor_utils_package_name | default(omit) }}" # AppArmor 유틸리티
        state: present
        update_cache: yes
      when: ansible_os_family == "Debian"

    # ... (SQLite 관련 작업들 유지) ...

    - name: Clean up downloaded OS vars directory from Play 1
      file:
        path: "{{ downloaded_vars_dir }}"
        state: absent
      # delegate_to: localhost
      # become: no # 현재 사용자 권한으로 삭제 시도

  handlers:
    - name: Run ldconfig
      command: ldconfig
      become: yes

    - name: Update alternatives for python3 # <--- 새 핸들러
      command: "update-alternatives --install /usr/bin/python3 python3 /usr/bin/python{{ python_target_version_short }} 1"
      when: ansible_os_family == "RedHat" # python_target_version_short 변수가 정의되었을 때
      # 우선순위(1)는 상황에 맞게 조정. 이미 python3가 alternatives로 관리되고 있다면
      # `update-alternatives --config python3`로 수동 선택하거나, 더 높은 우선순위 부여.
      # 또는, 이후 플레이북에서 python3 대신 python3.9 (또는 python{{ python_target_version_short }})를 명시적으로 사용.  

# --- 두 번째 플레이: Setup Django Web Environment (Multi-OS) ---
- name: Setup Django Web Environment (Multi-OS)
  hosts: localhost
  become: yes # 대부분의 작업은 root 권한이 필요하지만, 일부는 project_owner로 실행
  gather_facts: yes
  

  vars:
    # --- 실제 Django 프로젝트 소유자 정보 (동적 감지 또는 명시적 설정) ---
    # 1. Ansible 연결 사용자 사용 (Vagrant 'vagrant', AWS 'ec2-user' 등)
    target_project_user: "{{ ansible_user_id }}" # gather_facts로 수집된 연결 사용자 ID
    target_project_user_home: "{{ ansible_user_dir }}" # gather_facts로 수집된 연결 사용자 홈

    # 2. 또는 특정 사용자 명시 (필요시 주석 해제하고 위 1번 주석 처리)
    # target_project_user: "my_django_app_user"
    # target_project_user_home: "/home/{{ target_project_user }}"

    # --- Python 버전 관련 (첫 번째 플레이에서 설정한 값과 일치) ---
    python_target_version_short: "3.9" # 예시
    python_executable: "python{{ python_target_version_short }}" # 예: python3.9 (또는 alternatives 설정 후 python3)

    # ... (project_name, venv_dir 등 나머지 변수들은 이전과 유사하게 project_root_dir 기반으로 설정) ...
    django_project_name: "onpremweb"
    django_project_app_dirname: "{{ django_project_name }}_app"
    project_base_dir: "{{ target_project_user_home }}"
    project_root_dir: "{{ project_base_dir }}/{{ django_project_app_dirname }}"
    venv_dir: "{{ project_root_dir }}/venv"
    django_project_config_name: "onprem_project_config" # Django 프로젝트 내부 설정 디렉토리 (startproject 시 생성되는 이름)
    django_version: "3.2.25"

    # --- Apache 및 OS별 변수 로드 ---
    # 이 변수들은 첫 번째 플레이에서 set_fact로 설정되었거나, OS별 vars 파일에서 가져옴
    # apache_user, apache_group, apache_conf_dir 등은 OS별 vars 파일에 정의되어 있어야 함
    # (RedHat.yml, Debian.yml 확인 필요)

    # GitHub에서 가져오는 파일들 URL
    apache_conf_template_download_url: "https://raw.githubusercontent.com/negun2/soldesk/main/templates/django_onpremweb.conf.j2"
    apache_conf_template_downloaded_filename: "django_onpremweb.conf.j2"
    
    server_name_ip: "{{ ansible_default_ipv4.address if ansible_default_ipv4.address is defined else '127.0.0.1' }}"
    apache_wsgi_daemon_name: "{{ django_project_name }}_daemon" # 고유한 데몬 이름

  tasks:
    # --- OS별 변수 다시 로드 (두 번째 플레이를 독립적으로 실행할 경우 대비) ---
    # 첫 번째 플레이에서 이미 로드했지만, 이 플레이만 따로 실행할 경우를 위해 중복 포함 가능
    # 또는 첫 번째 플레이의 set_fact 결과를 hostvars로 참조 (더 효율적)
    # 여기서는 hostvars를 사용하는 방식으로 가정하고, 중복 로드 코드는 생략.
    # 만약 필요하다면 첫 번째 플레이의 변수 로드 부분을 여기에 다시 넣거나 include_role 등으로 분리.

    # --- 프로젝트 디렉토리 생성 및 소유권 설정 ---
    - name: Ensure project base directory (user's home) exists and has basic permissions
      file:
        path: "{{ project_base_dir }}" # 예: /home/vagrant
        state: directory
        owner: "{{ project_owner }}"
        group: "{{ project_owner }}" # 기본 그룹도 project_owner로
        mode: '0755' # 소유자 rwx, 그룹 rx, other rx (Apache가 접근하려면 최소 x 필요)
      become: yes # root로 생성/권한 보장

    - name: Ensure project root directory exists with project_owner ownership
      file:
        path: "{{ project_root_dir }}" # 예: /home/vagrant/onpremweb_app
        state: directory
        owner: "{{ project_owner }}"
        group: "{{ project_owner }}"
        mode: '0755' # 소유자 rwx, 그룹 rx, other rx
      become: yes # root로 생성 후 소유권 설정

    # --- 가상 환경 생성 및 패키지 설치 (project_owner 권한으로) ---
    - name: Create Python virtual environment with target Python version
      command: "{{ python_executable }} -m venv {{ venv_dir }}" # <--- 업그레이드된 Python 사용
      args:
        creates: "{{ venv_dir }}/bin/activate"
      become: yes
      become_user: "{{ target_project_user }}"

    # pip 설치 시에도 업그레이드된 Python의 pip 사용 (가상환경 내 pip 사용이므로 자동)
    - name: Install wheel in virtual environment
      pip:
        name: wheel
        virtualenv: "{{ venv_dir }}"
        # virtualenv_python: "{{ python_executable }}" # 명시적으로 지정 가능 (보통 자동 감지)
      become: yes
      become_user: "{{ target_project_user }}"
      # LD_LIBRARY_PATH 설정은 이제 불필요할 가능성 높음 (최신 Python이 해결)

    - name: Install Django, mod_wsgi (and pysqlite3-binary if still needed)
      pip:
        name:
          - "django=={{ django_version }}"
          - mod_wsgi
          # - pysqlite3-binary # <--- 최신 Python으로 해결되었다면 이 줄은 제거 가능
        virtualenv: "{{ venv_dir }}"
      become: yes
      become_user: "{{ target_project_user }}"

    - name: Check SQLite version in new venv
      command: "{{ venv_dir }}/bin/python -c \"import sqlite3; print(sqlite3.sqlite_version); print(sqlite3.connect(':memory:').execute('select sqlite_version()').fetchone())\"" # 추가 확인
      register: sqlite_version_in_new_venv
      changed_when: false
      become: yes
      become_user: "{{ target_project_user }}"

    - name: Debug SQLite version in new venv
      debug:
        var: sqlite_version_in_new_venv.stdout

    # --- Apache mod_wsgi 설정 ---
    # RedHat: /etc/httpd/conf.modules.d/10-wsgi-custom.conf
    # Debian: a2enmod wsgi_py3 (또는 wsgi)
    # 이 부분은 기존 로직 유지, OS별 변수(apache_conf_dir 등)가 정확해야 함.

    - name: Ensure mod_wsgi module is loaded and configured in Apache (RedHat family)
      blockinfile:
        path: "/etc/httpd/conf.modules.d/00-wsgi-custom.conf" # 기존 경로 또는 OS별 변수 사용
        block: |
          LoadModule wsgi_module modules/mod_wsgi_python3.so
          WSGISocketPrefix /var/run/wsgi
        create: yes
        owner: root
        group: root
        mode: '0644'
      when: ansible_os_family == "RedHat"
      notify: Restart Apache

    - name: Create WSGI socket directory (RedHat family)
      file:
        path: /var/run/wsgi # 이 경로는 Apache 사용자(예: apache)가 쓸 수 있어야 함
        state: directory
        owner: "{{ apache_user }}" # OS별 vars 파일에서 정의된 웹서버 사용자
        group: "{{ apache_group }}" # OS별 vars 파일에서 정의된 웹서버 그룹
        mode: '0755' # 또는 '0770'
      when: ansible_os_family == "RedHat"

    - name: Set SELinux context for WSGI socket directory (RedHat family)
      sefcontext:
        target: '/var/run/wsgi(/.*)?'
        setype: httpd_var_run_t
        state: present
      when: ansible_os_family == "RedHat" and ansible_selinux.status == "enabled" # SELinux 활성화 시에만
      notify: Restore wsgi socket dir SELinux context

    # Debian 계열 mod_wsgi 활성화 (기존 로직 유지)
    - name: Determine and Enable wsgi module (Debian family)
      block:
        - name: Check for wsgi_py3 module availability (Debian family)
          stat: path="/etc/apache2/mods-available/wsgi_py3.load"
          register: wsgi_py3_load_file_stat
        - name: Check for wsgi (generic) module availability (Debian family) - fallback
          stat: path="/etc/apache2/mods-available/wsgi.load"
          register: wsgi_load_file_stat
          when: not wsgi_py3_load_file_stat.stat.exists
        - name: Set correct wsgi module name for a2enmod (Debian family)
          set_fact:
            apache_wsgi_module_name_debian: >-
              {%- if wsgi_py3_load_file_stat.stat.exists -%}wsgi_py3
              {%- elif wsgi_load_file_stat.stat.exists -%}wsgi
              {%- else -%}{%- endif -%}
        - name: Enable wsgi module on Debian family
          command: "a2enmod {{ apache_wsgi_module_name_debian }}"
          args:
            creates: "/etc/apache2/mods-enabled/{{ apache_wsgi_module_name_debian }}.load"
          when: apache_wsgi_module_name_debian is defined and apache_wsgi_module_name_debian != ""
          notify: Restart Apache
          changed_when: true
      when: ansible_os_family == "Debian"

    # --- Django 프로젝트 생성 및 설정 (project_owner 권한으로) ---
    - name: Create Django project
      command: "{{ venv_dir }}/bin/django-admin startproject {{ django_project_config_name }} ."
      args:
        chdir: "{{ project_root_dir }}"
        creates: "{{ project_root_dir }}/manage.py"
      become: yes
      become_user: "{{ target_project_user }}"

    - name: Configure Django settings (ALLOWED_HOSTS, STATIC_ROOT, MEDIA_ROOT)
      lineinfile:
        path: "{{ project_root_dir }}/{{ django_project_config_name }}/settings.py"
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        insertafter: "{{ item.insertafter | default(omit) }}" # omit이면 파일 끝에 추가 (기본값)
        insertbefore: "{{ item.insertbefore | default(omit) }}"
        create: no # 파일은 이미 startproject로 생성됨
        owner: "{{ project_owner }}" # 파일 소유자 명시 (lineinfile은 owner/group 변경 안함)
        group: "{{ project_owner }}"
        mode: '0644' # 일반 파일 권한
      loop:
        - { regexp: "^ALLOWED_HOSTS = .*", line: "ALLOWED_HOSTS = ['*']" }
        - { regexp: "^# import os", line: "import os", insertbefore: "^BASE_DIR = .*" }
        - { regexp: "^STATIC_URL = .*", line: "STATIC_URL = '/static/'", insertafter: "^BASE_DIR = .*" } # BASE_DIR 다음에 오는 것이 좋음
        - { regexp: "^STATIC_ROOT = .*", line: "STATIC_ROOT = BASE_DIR / 'staticfiles'", insertafter: "STATIC_URL = '/static/'" }
        - { regexp: "^MEDIA_URL = .*", line: "MEDIA_URL = '/media/'", insertafter: "STATIC_ROOT = BASE_DIR / 'staticfiles'" }
        - { regexp: "^MEDIA_ROOT = .*", line: "MEDIA_ROOT = BASE_DIR / 'mediafiles'", insertafter: "MEDIA_URL = '/media/'" }
      become: yes # root로 파일 수정 (project_owner 소유 파일이므로 become_user도 가능)

    - name: Create staticfiles and mediafiles directories
      file:
        path: "{{ project_root_dir }}/{{ item }}"
        state: directory
        owner: "{{ project_owner }}"
        group: "{{ project_owner }}"
        mode: '0755'
      loop:
        - staticfiles
        - mediafiles
      become: yes
      become_user: "{{ project_owner }}" # project_owner 권한으로 생성

    - name: Collect static files
      command: "{{ venv_dir }}/bin/python manage.py collectstatic --noinput"
      args:
        chdir: "{{ project_root_dir }}"
      become: yes
      become_user: "{{ target_project_user }}"
      environment:
        PYTHONPATH: "{{ project_root_dir }}"
        DJANGO_SETTINGS_MODULE: "{{ django_project_config_name }}.settings"

    # --- Apache 접근을 위한 권한 설정 ---
    - name: Ensure Apache group can access project_owner's home directory path
      file:
        path: "{{ item }}"
        # owner/group은 건드리지 않음 (보통 root 또는 user 소유)
        mode: '0711' # u=rwx, g=x, o=x (다른 사용자가 디렉토리 리스팅은 못하지만, 내부 파일 접근은 가능하도록 x 권한 부여)
                     # 또는 mode: 'g+x' 로 그룹 실행 권한만 추가 (더 안전)
        state: directory
      # project_root_dir의 상위 디렉토리들에 대해 실행 권한(x) 부여
      # 예: /home, /home/vagrant
      loop: "{{ project_base_dir.split('/') | select() | map('join', '/') | map(attribute=' voorafgegaan door /') | list }}"
      # 위 loop는 복잡하므로, 간단히 project_base_dir에 대해서만 설정
      # 또는 알려진 상위 경로(/home)에 대해 설정
      become: yes
      when: "project_base_dir.startswith('/home')" # /home 아래인 경우에만

    - name: Set ACLs for Apache to access project directories (Alternative to changing group)
      acl:
        path: "{{ item.path }}"
        entity: "{{ apache_group }}" # OS별 웹서버 그룹
        etype: group
        permissions: "{{ item.permissions }}"
        state: present
        recursive: "{{ item.recursive | default(false) }}"
      loop:
        - { path: "{{ project_base_dir }}", permissions: "x", recursive: false } # 홈 디렉토리 자체에는 실행(탐색) 권한
        - { path: "{{ project_root_dir }}", permissions: "rX", recursive: true } # 프로젝트 루트와 하위에는 읽기 및 탐색 권한
        - { path: "{{ venv_dir }}", permissions: "rX", recursive: true } # 가상환경에도 읽기 및 탐색 권한
        # staticfiles, mediafiles는 project_root_dir recursive:true 로 커버됨
      become: yes
      when: ansible_os_family != "Darwin" # ACL 모듈은 macOS에서 기본 지원 안함, Linux에서 주로 사용. CentOS/RHEL은 acl 패키지 필요.

    # ACL 대신 전통적인 그룹 변경 방식 (선택)
    # - name: Change group of project files for Apache access
    #   file:
    #     path: "{{ item }}"
    #     group: "{{ apache_group }}"
    #     recurse: yes
    #   loop:
    #     - "{{ project_root_dir }}"
    #     - "{{ venv_dir }}" # venv도 Apache 그룹이 접근 가능해야 할 수 있음 (mod_wsgi)
    #   become: yes

    # - name: Set permissions for Apache group
    #   file:
    #     path: "{{ item.path }}"
    #     mode: "{{ item.mode }}" # 그룹에 r-x 권한 부여
    #     # owner는 project_owner 유지
    #   loop:
    #     - { path: "{{ project_root_dir }}", mode: '0750' } # u=rwx, g=rx, o=---
    #     - { path: "{{ project_root_dir }}/staticfiles", mode: '0750' } # 또는 0755 nếu other 읽기 허용
    #     - { path: "{{ project_root_dir }}/mediafiles", mode: '0750' }  # 또는 0755
    #     - { path: "{{ venv_dir }}", mode: '0750' }
    #   become: yes


    # --- Apache 가상 호스트 설정 ---
    - name: Download Apache config template to /tmp on VM
      get_url:
        url: "{{ apache_conf_template_download_url }}"
        dest: "/tmp/{{ apache_conf_template_downloaded_filename }}"
        mode: '0644'
      # delegate_to: localhost # 원격지(/tmp)에 다운로드

    - name: Deploy Apache virtual host configuration for Django
      template:
        src: "/tmp/{{ apache_conf_template_downloaded_filename }}"
        remote_src: yes # VM 내의 파일을 소스로 사용
        dest: "{{ apache_conf_dir }}/{{ django_project_name }}.conf" # OS별 conf.d 또는 sites-available
        owner: root
        group: root
        mode: '0644'
      notify: Restart Apache
      vars: # 템플릿에 전달할 변수 명시 (플레이북 vars와 템플릿 변수 이름이 동일하면 자동 전달되기도 함)
        apache_wsgi_daemon_name: "{{ apache_wsgi_daemon_name }}"
        apache_user: "{{ apache_user }}" # OS별 웹서버 유저
        apache_group: "{{ apache_group }}" # OS별 웹서버 그룹
        venv_dir: "{{ venv_dir }}"
        project_root_dir: "{{ project_root_dir }}"
        server_name_ip: "{{ server_name_ip }}"
        django_project_name: "{{ django_project_name }}"
        django_project_config_name: "{{ django_project_config_name }}"
        apache_log_dir: "{{ apache_log_dir }}" # OS별 로그 디렉토리

    - name: Clean up downloaded Apache template file from /tmp
      file:
        path: "/tmp/{{ apache_conf_template_downloaded_filename }}"
        state: absent
      # delegate_to: localhost

    # Debian 계열 사이트 활성화/비활성화 (기존 로직 유지)
    - name: Disable default Apache site (Debian family only)
      command: a2dissite 000-default.conf
      args:
        removes: "{{ apache_sites_enabled_dir }}/000-default.conf" # OS별 변수 사용
      when: ansible_os_family == "Debian" and apache_sites_enabled_dir is defined and apache_sites_enabled_dir != ""
      notify: Restart Apache
      register: disable_default_site_result
      changed_when: "'disabled' in disable_default_site_result.stdout"
      ignore_errors: yes # 이미 비활성화된 경우 대비

    - name: Enable Apache site for Django (Debian family only)
      command: "a2ensite {{ django_project_name }}"
      args:
        creates: "{{ apache_sites_enabled_dir }}/{{ django_project_name }}.conf" # OS별 변수 사용
      when: ansible_os_family == "Debian" and apache_sites_enabled_dir is defined and apache_sites_enabled_dir != ""
      notify: Restart Apache
      changed_when: true # a2ensite는 변경 시 보통 0을 반환, creates로 멱등성 확보

    - name: Ensure Apache service is enabled and running
      service:
        name: "{{ apache_service_name }}" # OS별 서비스 이름
        state: started
        enabled: yes

    # --- SELinux 설정 (RedHat 계열) ---
    - name: Configure SELinux for Apache serving from user home (RedHat family only)
      block:
        - name: Ensure policycoreutils-python is installed for semanage/sefcontext
          yum:
            name: "{{ policycoreutils_package_name | default('policycoreutils-python') }}" # RedHat.yml에 정의된 것 사용
            state: present
          when: policycoreutils_package_name is defined and policycoreutils_package_name != ""

        - name: Allow httpd to access project files in user home (SELinux context)
          sefcontext:
            target: "{{ project_root_dir }}(/.*)?" # 예: /home/vagrant/onpremweb_app(/.*)?
            setype: httpd_sys_content_t
            state: present
          notify: Restore SELinux context

        - name: Allow httpd to write to media directory (SELinux context)
          sefcontext:
            target: "{{ project_root_dir }}/mediafiles(/.*)?"
            setype: httpd_sys_rw_content_t # Django가 미디어 파일 업로드 시 필요
            state: present
          notify: Restore SELinux context
        
        - name: Allow httpd to access user home directories (SELinux boolean)
          seboolean:
            name: httpd_enable_homedirs
            state: yes
            persistent: yes # 재부팅 후에도 유지

        - name: Allow httpd to make network connections (if Django needs to connect to external services)
          seboolean:
            name: httpd_can_network_connect
            state: yes
            persistent: yes
        
        # SQLite는 로컬 파일이므로 httpd_can_network_connect_db는 필수 아님.
        # 외부 DB 사용 시 필요.
        # - name: Allow httpd to connect to databases (if using external DB)
        #   seboolean:
        #     name: httpd_can_network_connect_db
        #     state: yes
        #     persistent: yes

      when: ansible_os_family == "RedHat" and ansible_selinux.status == "enabled" # SELinux 활성화 시에만 실행
      ignore_errors: yes # semanage/seboolean 관련 오류 발생 시 플레이북 중단 방지 (디버깅 필요)

  handlers:
    - name: Restart Apache
      service:
        name: "{{ apache_service_name }}" # OS별 서비스 이름 사용
        state: restarted
      become: yes

    - name: Restore SELinux context
      command: "restorecon -Rv {{ project_root_dir }}"
      when: ansible_os_family == "RedHat" and ansible_selinux.status == "enabled"
      become: yes

    - name: Restore wsgi socket dir SELinux context
      command: "restorecon -Rv /var/run/wsgi" # WSGISocketPrefix 경로
      when: ansible_os_family == "RedHat" and ansible_selinux.status == "enabled"
      become: yes

    # Firewall 핸들러는 현재 플레이북에서 직접 사용되지 않으므로 생략 가능 (필요시 추가)
